#!/usr/bin/env python3
from pathlib import Path
import re
import typing as t
from dataclasses import dataclass
import textwrap
import inspect

# Typically use _file__ but it doesn't work when being run from platformio
src_file_path = inspect.getfile(lambda: None)
PROJECT_ROOT = Path(src_file_path).absolute().parent.parent
SOURCE_DIR = PROJECT_ROOT.joinpath('src')

@dataclass
class StructField:
    name: str
    c_type: str
    python_type: str = 'object'
    python_struct_fmt: str = 'P' # void


def gen_telemetry(telemetry_filepath: str, output_path: str) -> str:
    with open(telemetry_filepath) as f:
        data = f.read()

    start_tag = '// -- TELEMTRY_START START -- //'
    end_tag = '// -- TELEMTRY_START END -- //'
    pattern = rf'{start_tag}\s*(.*?)\s*{end_tag}'
    telemetry_struct = re.search(pattern, data, flags=re.DOTALL)

    if not telemetry_struct:
        raise RuntimeError(f'Failed to parse telemetry struct from file {telemetry_filepath}. Wrong format!')

    def parse_fields(struct_str: str) -> t.List[StructField]:
        fields = []
        parse_fields = False
        for line in struct_str.splitlines():
            line = line.lstrip()
            if line.startswith('{'):
                parse_fields = True
                continue
            elif line.startswith('/'):
                # Comment
                continue
            elif line.startswith('}'):
                break
            
            if parse_fields:
                # Remove ; to get field data
                line_trimmed = line.split(';')[0].strip()
                # Replace potential duplicate white space with single
                line_trimmed = re.sub(r'\s+', ' ', line_trimmed)
                # Split data type and its name
                dtype_and_name = line_trimmed.split(' ')
                if not len(dtype_and_name) == 2:
                    print(f'ERROR: Invalid field line {line}')
                    continue
                dtype, name = dtype_and_name
                dtype = dtype.strip()
                name = name.strip()
                fields.append(StructField(name, dtype))

        return fields

    telemetry_str = telemetry_struct.group(1)
    
    # Parse fields of the struct
    fields = parse_fields(telemetry_str)
    
    def get_python_type(c_dtype: str) -> None:
        ctypes = {
            'uint8_t': ('int', 'B'),
            'int8_t': ('int', 'b'),
            'uint16_t': ('int', 'H'),
            'int16_t': ('int', 'h'),
            'uint32_t': ('int', 'I'),
            'int32_t': ('int', 'i'),
            'uint64_t': ('int', 'L'),
            'int64_t': ('int', 'l'),
            'float': ('float', 'f'),
            'bool': ('bool', 'B'),
            'char': ('str', 'c')
        }
        return ctypes.get(c_dtype)

    # Build correct python types
    for field in fields:
        python_type = get_python_type(field.c_type)
        if not python_type:
            print(f'ERROR: Cannot find python type for field {field.c_type} ({field.name})!')
            continue

        python_type, python_struct_fmt =  python_type
        field.python_type = python_type
        field.python_struct_fmt = python_struct_fmt
    
    # Generate output
    print(f'Generating output to {output_path}')
    with open(output_path, 'w') as f:
        text = textwrap.dedent(
        '''
        from dataclasses import dataclass, asdict
        from telemetry_packet import TelemetryPacket

        # -- This file is autogenerated -- #

        @dataclass
        class TelemetryStatus(TelemetryPacket):
        '''
        )
        fmt = '<'
        for field in fields:
            text += f'    {field.name}: {field.python_type}  # {field.c_type}\n'
            fmt += field.python_struct_fmt
        text += f'\n    _fmt = \'{fmt}\''

        f.write(text)
    


def main():
    print('Generating telemetry')
    telem_input_file = SOURCE_DIR.joinpath('telemetry.h')
    output_file = PROJECT_ROOT.joinpath('tools', 'telemetry_def.py')
    gen_telemetry(telem_input_file, output_file)

if '__file__' in globals():
    if __name__ == '__main__':
        main()
else:
    # Being called from platformio, we're not running as main script
    main()

